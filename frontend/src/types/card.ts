// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "card.proto" (package "card", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message card.Card
 */
export interface Card {
    /**
     * @generated from protobuf field: card.CardValue value = 1;
     */
    value: CardValue;
    /**
     * @generated from protobuf field: card.CardSuit suit = 2;
     */
    suit: CardSuit;
}
/**
 * @generated from protobuf message card.CardPair
 */
export interface CardPair {
    /**
     * @generated from protobuf field: card.Card card1 = 1;
     */
    card1?: Card;
    /**
     * @generated from protobuf field: card.Card card2 = 2;
     */
    card2?: Card;
}
/**
 * @generated from protobuf enum card.CardValue
 */
export enum CardValue {
    /**
     * @generated from protobuf enum value: Two = 0;
     */
    Two = 0,
    /**
     * @generated from protobuf enum value: Three = 1;
     */
    Three = 1,
    /**
     * @generated from protobuf enum value: Four = 2;
     */
    Four = 2,
    /**
     * @generated from protobuf enum value: Five = 3;
     */
    Five = 3,
    /**
     * @generated from protobuf enum value: Six = 4;
     */
    Six = 4,
    /**
     * @generated from protobuf enum value: Seven = 5;
     */
    Seven = 5,
    /**
     * @generated from protobuf enum value: Eight = 6;
     */
    Eight = 6,
    /**
     * @generated from protobuf enum value: Nine = 7;
     */
    Nine = 7,
    /**
     * @generated from protobuf enum value: Ten = 8;
     */
    Ten = 8,
    /**
     * @generated from protobuf enum value: Jack = 9;
     */
    Jack = 9,
    /**
     * @generated from protobuf enum value: Queen = 10;
     */
    Queen = 10,
    /**
     * @generated from protobuf enum value: King = 11;
     */
    King = 11,
    /**
     * @generated from protobuf enum value: Ace = 12;
     */
    Ace = 12
}
/**
 * @generated from protobuf enum card.CardSuit
 */
export enum CardSuit {
    /**
     * @generated from protobuf enum value: Clubs = 0;
     */
    Clubs = 0,
    /**
     * @generated from protobuf enum value: Spades = 1;
     */
    Spades = 1,
    /**
     * @generated from protobuf enum value: Hearts = 2;
     */
    Hearts = 2,
    /**
     * @generated from protobuf enum value: Diamonds = 3;
     */
    Diamonds = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Card$Type extends MessageType<Card> {
    constructor() {
        super("card.Card", [
            { no: 1, name: "value", kind: "enum", T: () => ["card.CardValue", CardValue] },
            { no: 2, name: "suit", kind: "enum", T: () => ["card.CardSuit", CardSuit] }
        ]);
    }
    create(value?: PartialMessage<Card>): Card {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        message.suit = 0;
        if (value !== undefined)
            reflectionMergePartial<Card>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Card): Card {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* card.CardValue value */ 1:
                    message.value = reader.int32();
                    break;
                case /* card.CardSuit suit */ 2:
                    message.suit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Card, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* card.CardValue value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).int32(message.value);
        /* card.CardSuit suit = 2; */
        if (message.suit !== 0)
            writer.tag(2, WireType.Varint).int32(message.suit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message card.Card
 */
export const Card = new Card$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CardPair$Type extends MessageType<CardPair> {
    constructor() {
        super("card.CardPair", [
            { no: 1, name: "card1", kind: "message", T: () => Card },
            { no: 2, name: "card2", kind: "message", T: () => Card }
        ]);
    }
    create(value?: PartialMessage<CardPair>): CardPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CardPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CardPair): CardPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* card.Card card1 */ 1:
                    message.card1 = Card.internalBinaryRead(reader, reader.uint32(), options, message.card1);
                    break;
                case /* card.Card card2 */ 2:
                    message.card2 = Card.internalBinaryRead(reader, reader.uint32(), options, message.card2);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CardPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* card.Card card1 = 1; */
        if (message.card1)
            Card.internalBinaryWrite(message.card1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* card.Card card2 = 2; */
        if (message.card2)
            Card.internalBinaryWrite(message.card2, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message card.CardPair
 */
export const CardPair = new CardPair$Type();
